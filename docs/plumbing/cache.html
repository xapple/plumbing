<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>plumbing.cache API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>plumbing.cache</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Built-in modules #
import os, time, inspect, tempfile, pickle, hashlib, base64

# Internal modules #
from autopaths import Path

################################################################################
def cached(f):
    &#34;&#34;&#34;Decorator for functions evaluated only once.&#34;&#34;&#34;
    def memoized(*args, **kwargs):
        if hasattr(memoized, &#39;__cache__&#39;):
            return memoized.__cache__
        result = f(*args, **kwargs)
        memoized.__cache__ = result
        return result
    return memoized

###############################################################################
class property_cached(object):
    &#34;&#34;&#34;
    This decorator converts a method with a single self argument
    into a property cached on the instance.

    In other words, it&#39;s like `@property` but memoized.

        from plumbing.cache import property_cached

        class Square:
            def __init__(self, size):
                self.size = size

            @property_cached
            def area(self):
                print(&#34;Evaluating...&#34;)
                return self.size * self.size

        shape = Square(5)
        print(shape.size)
        print(shape.area)  # Area computed the first time
        shape.area = 99    # Now update an attribute
        print(shape.area)  # Same result returned, not recomputed
        del shape.area     # This will purge the cache
        print(shape.area)  # Updated result, it&#39;s computed again
    &#34;&#34;&#34;

    def __init__(self, func):
        self.func    = func
        self.__doc__ = getattr(func, &#39;__doc__&#39;)
        self.name    = self.func.__name__

    def __get__(self, instance, owner):
        &#34;&#34;&#34;
        If you see the current source code in a seemingly unrelated part of
        an auto-generated documentation, it means the program making the
        documentation was unable to correctly traverse a decorated property.
        &#34;&#34;&#34;
        # If called from a class #
        if instance is None: return self
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Is the answer in the cache? #
        if self.name in instance.__cache__: return instance.__cache__[self.name]
        # If not we will compute it #
        if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
        else:                                      result = self.func(instance)
        # Let&#39;s store the answer for later #
        instance.__cache__[self.name] = result
        # Return #
        return result

    def __set__(self, instance, value):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Overwrite the value #
        instance.__cache__[self.name] = value

    def __delete__(self, instance):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Remove the key #
        instance.__cache__.pop(self.name, None)

    def check_cache(self, instance):
        if &#39;__cache__&#39; not in instance.__dict__: instance.__cache__ = {}

###############################################################################
class property_pickled(object):
    &#34;&#34;&#34;
    Same thing as `property_cached` but the cache will be stored on disk
    with the `pickle` module. So you should check that the return value of the
    function you decorate can be pickled. Otherwise checkout the `dill` module.

    The path of the pickle file will be determined by looking for the
    `cache_dir` attribute of the instance containing the cached property
    and combining the function name with a &#39;.pickle&#39; at the end.

    If no `cache_dir` attribute exists it, a default location will be
    chosen (tmpdir). But this will have for effect that all instances of the
    class will have the same cached value (works well for singletons only).

    The location will default to the temporary directory plus a very short
    hash of the function&#39;s import path, so you could get something like this:

        /var/temporary/pickled_properties/EfEZTAubgXI
    &#34;&#34;&#34;

    def __init__(self, func, at=None):
        # Record the function that we are decorating #
        self.func    = func
        # Set the documentation string of the underlying function here #
        self.__doc__ = getattr(func, &#39;__doc__&#39;)
        # Get the plain name of the function #
        self.name    = self.func.__name__
        # Optionally specify the location at which we should pickle #
        self.at      = at

    def __get__(self, instance, owner):
        &#34;&#34;&#34;
        If you see the current source code in a seemingly unrelated part of
        an auto-generated documentation, it means the program making the
        documentation was unable to correctly traverse a decorated property.
        &#34;&#34;&#34;
        # If called from a class #
        if instance is None: return self
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Is the answer in the cache? #
        if self.name in instance.__cache__: return instance.__cache__[self.name]
        # Where should we look in the file system ? #
        path = self.get_pickle_path(instance)
        # Is the answer already on the file system? #
        if path.exists:
            with open(path, &#39;rb&#39;) as handle: result = pickle.load(handle)
            instance.__cache__[self.name] = result
            return result
        # If not we will compute it #
        if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
        else:                                      result = self.func(instance)
        # Let&#39;s store the answer for later in the cache #
        instance.__cache__[self.name] = result
        # And also store it on the disk #
        with open(path, &#39;wb&#39;) as handle: pickle.dump(result, handle)
        # Return #
        return result

    def __set__(self, instance, value):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Overwrite the value in memory #
        instance.__cache__[self.name] = value
        # Where should we look in the file system ? #
        path = self.get_pickle_path(instance)
        # And also overwrite it on the disk #
        with open(path, &#39;wb&#39;) as handle: pickle.dump(value, handle)

    def __delete__(self, instance):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Remove the key #
        instance.__cache__.pop(self.name, None)
        # And remove the file on disk #
        path = self.get_pickle_path(instance)
        path.remove()

    def check_cache(self, instance):
        if &#39;__cache__&#39; not in instance.__dict__: instance.__cache__ = {}

    def get_pickle_path(self, instance):
        # First check if an `at` parameter was specified #
        if self.at is not None: path = Path(getattr(instance, self.at))
        # Secondly check if the instance has a cache_dir specified #
        elif &#39;cache_dir&#39; in instance.__dict__:
            path = Path(instance.cache_dir + self.name + &#39;.pickle&#39;)
        # Otherwise we go the default route (no instance passed) #
        else: path = Path(self.get_default_path())
        # Make the directory #
        path.make_directory()
        return path

    def get_default_path(self):
        # Get the temporary directory (platform dependant) #
        path = tempfile.gettempdir() + &#39;/pickled_properties/&#39;
        # Create that directory if it doesn&#39;t exist #
        os.makedirs(path, exist_ok=True)
        # Find the function&#39;s import path in the package namespace #
        func_loc = self.func.__module__ + &#39;.&#39; + self.name
        # Make a short safe name from the import path #
        short_name = hashlib.md5(func_loc.encode()).digest()[:8]
        short_name = base64.urlsafe_b64encode(short_name).decode()
        short_name = short_name.replace(&#39;=&#39;,&#39;&#39;)
        # Return #
        return path + short_name

################################################################################
def property_pickled_at(at):
    &#34;&#34;&#34;
    Same thing as above, but you can specify the name of another property as
    a string, that will be called on the instance once to determine the
    path at which to write and load the pickle file from. This property should
    hence return the same path for every equivalent instance.
    &#34;&#34;&#34;
    def wrapper(function): return property_pickled(function, at=at)
    return wrapper

################################################################################
def expiry_every(seconds=0):
    def memoize_with_expiry(func, *args, **kwargs):
        # Get the cache #
        if not hasattr(func, &#39;__cache__&#39;): func.__cache__ = [(0,0)]
        cache = func.__cache__
        # Check the cache #
        if cache:
            result, timestamp = cache[0]
            age = time.time() - timestamp
            if age &lt; seconds: return result
        # Update the cache #
        result = func(*args, **kwargs)
        cache[0] = (result, time.time())
        # Return #
        return result
    from decorator import decorator
    return decorator(memoize_with_expiry)

###############################################################################
class LazyString(object):
    &#34;&#34;&#34;A string-like object that will only compute its value once, when accessed.&#34;&#34;&#34;
    def __str__(self): return self.value

    def __init__(self, function):
        self._value = None
        self.function = function

    @property
    def value(self):
        if self._value is None: self._value = self.function()
        return self._value

###############################################################################
class LazyDict(object):
    &#34;&#34;&#34;A dictionary-like object that will only compute its value once, when accessed.&#34;&#34;&#34;
    def __getitem__(self, item): return self.value[item]

    def __init__(self, function):
        self._value = None
        self.function = function

    @property
    def value(self):
        if self._value is None: self._value = self.function()
        return self._value

###############################################################################
class LazyList(object):
    &#34;&#34;&#34;A list-like object that will only compute its value once, when accessed.&#34;&#34;&#34;
    def __iter__(self): return iter(self.value)
    def __len__(self):  return len(self.value)

    def __init__(self, function):
        self._value = None
        self.function = function

    @property
    def value(self):
        if self._value is None: self._value = self.function()
        return self._value

###############################################################################
class class_property(property):
    &#34;&#34;&#34;You can use this like this:
        class Foo(object):
            @class_property
            @classmethod
            @cached
            def bar(cls):
                return 1+1
    &#34;&#34;&#34;
    def __get__(self, cls, owner):
        return self.fget.__get__(None, owner)()

###############################################################################
class invalidate_cache(object):
    &#34;&#34;&#34;
    Adds a hook to allow for another property setter to
    invalidated a part of the cache.

        class Square(object):
            def __init__(self, size):
                self._size = size

            @property
            def size(self):
                return self._size

            @cached_property
            def area(self):
                print(&#34;Evaluating...&#34;)
                return self.size * self.size

            @size.setter
            @invalidate_cache(&#34;area&#34;)
            def size(self, size):
                self._size = size

    shape = Square(5)
    print(shape.size)
    print(shape.area)
    shape.size = 6
    print(shape.area)
    &#34;&#34;&#34;

    def __init__(self, func):
        self.func    = func
        self.__doc__ = getattr(func, &#39;__doc__&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="plumbing.cache.cached"><code class="name flex">
<span>def <span class="ident">cached</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for functions evaluated only once.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cached(f):
    &#34;&#34;&#34;Decorator for functions evaluated only once.&#34;&#34;&#34;
    def memoized(*args, **kwargs):
        if hasattr(memoized, &#39;__cache__&#39;):
            return memoized.__cache__
        result = f(*args, **kwargs)
        memoized.__cache__ = result
        return result
    return memoized</code></pre>
</details>
</dd>
<dt id="plumbing.cache.expiry_every"><code class="name flex">
<span>def <span class="ident">expiry_every</span></span>(<span>seconds=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expiry_every(seconds=0):
    def memoize_with_expiry(func, *args, **kwargs):
        # Get the cache #
        if not hasattr(func, &#39;__cache__&#39;): func.__cache__ = [(0,0)]
        cache = func.__cache__
        # Check the cache #
        if cache:
            result, timestamp = cache[0]
            age = time.time() - timestamp
            if age &lt; seconds: return result
        # Update the cache #
        result = func(*args, **kwargs)
        cache[0] = (result, time.time())
        # Return #
        return result
    from decorator import decorator
    return decorator(memoize_with_expiry)</code></pre>
</details>
</dd>
<dt id="plumbing.cache.property_pickled_at"><code class="name flex">
<span>def <span class="ident">property_pickled_at</span></span>(<span>at)</span>
</code></dt>
<dd>
<div class="desc"><p>Same thing as above, but you can specify the name of another property as
a string, that will be called on the instance once to determine the
path at which to write and load the pickle file from. This property should
hence return the same path for every equivalent instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def property_pickled_at(at):
    &#34;&#34;&#34;
    Same thing as above, but you can specify the name of another property as
    a string, that will be called on the instance once to determine the
    path at which to write and load the pickle file from. This property should
    hence return the same path for every equivalent instance.
    &#34;&#34;&#34;
    def wrapper(function): return property_pickled(function, at=at)
    return wrapper</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="plumbing.cache.LazyDict"><code class="flex name class">
<span>class <span class="ident">LazyDict</span></span>
<span>(</span><span>function)</span>
</code></dt>
<dd>
<div class="desc"><p>A dictionary-like object that will only compute its value once, when accessed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LazyDict(object):
    &#34;&#34;&#34;A dictionary-like object that will only compute its value once, when accessed.&#34;&#34;&#34;
    def __getitem__(self, item): return self.value[item]

    def __init__(self, function):
        self._value = None
        self.function = function

    @property
    def value(self):
        if self._value is None: self._value = self.function()
        return self._value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="plumbing.cache.LazyDict.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    if self._value is None: self._value = self.function()
    return self._value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="plumbing.cache.LazyList"><code class="flex name class">
<span>class <span class="ident">LazyList</span></span>
<span>(</span><span>function)</span>
</code></dt>
<dd>
<div class="desc"><p>A list-like object that will only compute its value once, when accessed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LazyList(object):
    &#34;&#34;&#34;A list-like object that will only compute its value once, when accessed.&#34;&#34;&#34;
    def __iter__(self): return iter(self.value)
    def __len__(self):  return len(self.value)

    def __init__(self, function):
        self._value = None
        self.function = function

    @property
    def value(self):
        if self._value is None: self._value = self.function()
        return self._value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="plumbing.cache.LazyList.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    if self._value is None: self._value = self.function()
    return self._value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="plumbing.cache.LazyString"><code class="flex name class">
<span>class <span class="ident">LazyString</span></span>
<span>(</span><span>function)</span>
</code></dt>
<dd>
<div class="desc"><p>A string-like object that will only compute its value once, when accessed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LazyString(object):
    &#34;&#34;&#34;A string-like object that will only compute its value once, when accessed.&#34;&#34;&#34;
    def __str__(self): return self.value

    def __init__(self, function):
        self._value = None
        self.function = function

    @property
    def value(self):
        if self._value is None: self._value = self.function()
        return self._value</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="plumbing.cache.LazyString.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def value(self):
    if self._value is None: self._value = self.function()
    return self._value</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="plumbing.cache.class_property"><code class="flex name class">
<span>class <span class="ident">class_property</span></span>
<span>(</span><span>fget=None, fset=None, fdel=None, doc=None)</span>
</code></dt>
<dd>
<div class="desc"><p>You can use this like this:
class Foo(object):
@class_property
@classmethod
@cached
def bar(cls):
return 1+1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class class_property(property):
    &#34;&#34;&#34;You can use this like this:
        class Foo(object):
            @class_property
            @classmethod
            @cached
            def bar(cls):
                return 1+1
    &#34;&#34;&#34;
    def __get__(self, cls, owner):
        return self.fget.__get__(None, owner)()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.property</li>
</ul>
</dd>
<dt id="plumbing.cache.invalidate_cache"><code class="flex name class">
<span>class <span class="ident">invalidate_cache</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a hook to allow for another property setter to
invalidated a part of the cache.</p>
<pre><code>class Square(object):
    def __init__(self, size):
        self._size = size

    @property
    def size(self):
        return self._size

    @cached_property
    def area(self):
        print("Evaluating...")
        return self.size * self.size

    @size.setter
    @invalidate_cache("area")
    def size(self, size):
        self._size = size
</code></pre>
<p>shape = Square(5)
print(shape.size)
print(shape.area)
shape.size = 6
print(shape.area)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class invalidate_cache(object):
    &#34;&#34;&#34;
    Adds a hook to allow for another property setter to
    invalidated a part of the cache.

        class Square(object):
            def __init__(self, size):
                self._size = size

            @property
            def size(self):
                return self._size

            @cached_property
            def area(self):
                print(&#34;Evaluating...&#34;)
                return self.size * self.size

            @size.setter
            @invalidate_cache(&#34;area&#34;)
            def size(self, size):
                self._size = size

    shape = Square(5)
    print(shape.size)
    print(shape.area)
    shape.size = 6
    print(shape.area)
    &#34;&#34;&#34;

    def __init__(self, func):
        self.func    = func
        self.__doc__ = getattr(func, &#39;__doc__&#39;)</code></pre>
</details>
</dd>
<dt id="plumbing.cache.property_cached"><code class="flex name class">
<span>class <span class="ident">property_cached</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<div class="desc"><p>This decorator converts a method with a single self argument
into a property cached on the instance.</p>
<p>In other words, it's like <code>@property</code> but memoized.</p>
<pre><code>from plumbing.cache import property_cached

class Square:
    def __init__(self, size):
        self.size = size

    @property_cached
    def area(self):
        print("Evaluating...")
        return self.size * self.size

shape = Square(5)
print(shape.size)
print(shape.area)  # Area computed the first time
shape.area = 99    # Now update an attribute
print(shape.area)  # Same result returned, not recomputed
del shape.area     # This will purge the cache
print(shape.area)  # Updated result, it's computed again
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class property_cached(object):
    &#34;&#34;&#34;
    This decorator converts a method with a single self argument
    into a property cached on the instance.

    In other words, it&#39;s like `@property` but memoized.

        from plumbing.cache import property_cached

        class Square:
            def __init__(self, size):
                self.size = size

            @property_cached
            def area(self):
                print(&#34;Evaluating...&#34;)
                return self.size * self.size

        shape = Square(5)
        print(shape.size)
        print(shape.area)  # Area computed the first time
        shape.area = 99    # Now update an attribute
        print(shape.area)  # Same result returned, not recomputed
        del shape.area     # This will purge the cache
        print(shape.area)  # Updated result, it&#39;s computed again
    &#34;&#34;&#34;

    def __init__(self, func):
        self.func    = func
        self.__doc__ = getattr(func, &#39;__doc__&#39;)
        self.name    = self.func.__name__

    def __get__(self, instance, owner):
        &#34;&#34;&#34;
        If you see the current source code in a seemingly unrelated part of
        an auto-generated documentation, it means the program making the
        documentation was unable to correctly traverse a decorated property.
        &#34;&#34;&#34;
        # If called from a class #
        if instance is None: return self
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Is the answer in the cache? #
        if self.name in instance.__cache__: return instance.__cache__[self.name]
        # If not we will compute it #
        if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
        else:                                      result = self.func(instance)
        # Let&#39;s store the answer for later #
        instance.__cache__[self.name] = result
        # Return #
        return result

    def __set__(self, instance, value):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Overwrite the value #
        instance.__cache__[self.name] = value

    def __delete__(self, instance):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Remove the key #
        instance.__cache__.pop(self.name, None)

    def check_cache(self, instance):
        if &#39;__cache__&#39; not in instance.__dict__: instance.__cache__ = {}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="plumbing.cache.property_cached.check_cache"><code class="name flex">
<span>def <span class="ident">check_cache</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cache(self, instance):
    if &#39;__cache__&#39; not in instance.__dict__: instance.__cache__ = {}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="plumbing.cache.property_pickled"><code class="flex name class">
<span>class <span class="ident">property_pickled</span></span>
<span>(</span><span>func, at=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Same thing as <code><a title="plumbing.cache.property_cached" href="#plumbing.cache.property_cached">property_cached</a></code> but the cache will be stored on disk
with the <code>pickle</code> module. So you should check that the return value of the
function you decorate can be pickled. Otherwise checkout the <code>dill</code> module.</p>
<p>The path of the pickle file will be determined by looking for the
<code>cache_dir</code> attribute of the instance containing the cached property
and combining the function name with a '.pickle' at the end.</p>
<p>If no <code>cache_dir</code> attribute exists it, a default location will be
chosen (tmpdir). But this will have for effect that all instances of the
class will have the same cached value (works well for singletons only).</p>
<p>The location will default to the temporary directory plus a very short
hash of the function's import path, so you could get something like this:</p>
<pre><code>/var/temporary/pickled_properties/EfEZTAubgXI
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class property_pickled(object):
    &#34;&#34;&#34;
    Same thing as `property_cached` but the cache will be stored on disk
    with the `pickle` module. So you should check that the return value of the
    function you decorate can be pickled. Otherwise checkout the `dill` module.

    The path of the pickle file will be determined by looking for the
    `cache_dir` attribute of the instance containing the cached property
    and combining the function name with a &#39;.pickle&#39; at the end.

    If no `cache_dir` attribute exists it, a default location will be
    chosen (tmpdir). But this will have for effect that all instances of the
    class will have the same cached value (works well for singletons only).

    The location will default to the temporary directory plus a very short
    hash of the function&#39;s import path, so you could get something like this:

        /var/temporary/pickled_properties/EfEZTAubgXI
    &#34;&#34;&#34;

    def __init__(self, func, at=None):
        # Record the function that we are decorating #
        self.func    = func
        # Set the documentation string of the underlying function here #
        self.__doc__ = getattr(func, &#39;__doc__&#39;)
        # Get the plain name of the function #
        self.name    = self.func.__name__
        # Optionally specify the location at which we should pickle #
        self.at      = at

    def __get__(self, instance, owner):
        &#34;&#34;&#34;
        If you see the current source code in a seemingly unrelated part of
        an auto-generated documentation, it means the program making the
        documentation was unable to correctly traverse a decorated property.
        &#34;&#34;&#34;
        # If called from a class #
        if instance is None: return self
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Is the answer in the cache? #
        if self.name in instance.__cache__: return instance.__cache__[self.name]
        # Where should we look in the file system ? #
        path = self.get_pickle_path(instance)
        # Is the answer already on the file system? #
        if path.exists:
            with open(path, &#39;rb&#39;) as handle: result = pickle.load(handle)
            instance.__cache__[self.name] = result
            return result
        # If not we will compute it #
        if inspect.isgeneratorfunction(self.func): result = tuple(self.func(instance))
        else:                                      result = self.func(instance)
        # Let&#39;s store the answer for later in the cache #
        instance.__cache__[self.name] = result
        # And also store it on the disk #
        with open(path, &#39;wb&#39;) as handle: pickle.dump(result, handle)
        # Return #
        return result

    def __set__(self, instance, value):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Overwrite the value in memory #
        instance.__cache__[self.name] = value
        # Where should we look in the file system ? #
        path = self.get_pickle_path(instance)
        # And also overwrite it on the disk #
        with open(path, &#39;wb&#39;) as handle: pickle.dump(value, handle)

    def __delete__(self, instance):
        # Does a cache exist for this instance? #
        self.check_cache(instance)
        # Remove the key #
        instance.__cache__.pop(self.name, None)
        # And remove the file on disk #
        path = self.get_pickle_path(instance)
        path.remove()

    def check_cache(self, instance):
        if &#39;__cache__&#39; not in instance.__dict__: instance.__cache__ = {}

    def get_pickle_path(self, instance):
        # First check if an `at` parameter was specified #
        if self.at is not None: path = Path(getattr(instance, self.at))
        # Secondly check if the instance has a cache_dir specified #
        elif &#39;cache_dir&#39; in instance.__dict__:
            path = Path(instance.cache_dir + self.name + &#39;.pickle&#39;)
        # Otherwise we go the default route (no instance passed) #
        else: path = Path(self.get_default_path())
        # Make the directory #
        path.make_directory()
        return path

    def get_default_path(self):
        # Get the temporary directory (platform dependant) #
        path = tempfile.gettempdir() + &#39;/pickled_properties/&#39;
        # Create that directory if it doesn&#39;t exist #
        os.makedirs(path, exist_ok=True)
        # Find the function&#39;s import path in the package namespace #
        func_loc = self.func.__module__ + &#39;.&#39; + self.name
        # Make a short safe name from the import path #
        short_name = hashlib.md5(func_loc.encode()).digest()[:8]
        short_name = base64.urlsafe_b64encode(short_name).decode()
        short_name = short_name.replace(&#39;=&#39;,&#39;&#39;)
        # Return #
        return path + short_name</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="plumbing.cache.property_pickled.check_cache"><code class="name flex">
<span>def <span class="ident">check_cache</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_cache(self, instance):
    if &#39;__cache__&#39; not in instance.__dict__: instance.__cache__ = {}</code></pre>
</details>
</dd>
<dt id="plumbing.cache.property_pickled.get_default_path"><code class="name flex">
<span>def <span class="ident">get_default_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_path(self):
    # Get the temporary directory (platform dependant) #
    path = tempfile.gettempdir() + &#39;/pickled_properties/&#39;
    # Create that directory if it doesn&#39;t exist #
    os.makedirs(path, exist_ok=True)
    # Find the function&#39;s import path in the package namespace #
    func_loc = self.func.__module__ + &#39;.&#39; + self.name
    # Make a short safe name from the import path #
    short_name = hashlib.md5(func_loc.encode()).digest()[:8]
    short_name = base64.urlsafe_b64encode(short_name).decode()
    short_name = short_name.replace(&#39;=&#39;,&#39;&#39;)
    # Return #
    return path + short_name</code></pre>
</details>
</dd>
<dt id="plumbing.cache.property_pickled.get_pickle_path"><code class="name flex">
<span>def <span class="ident">get_pickle_path</span></span>(<span>self, instance)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pickle_path(self, instance):
    # First check if an `at` parameter was specified #
    if self.at is not None: path = Path(getattr(instance, self.at))
    # Secondly check if the instance has a cache_dir specified #
    elif &#39;cache_dir&#39; in instance.__dict__:
        path = Path(instance.cache_dir + self.name + &#39;.pickle&#39;)
    # Otherwise we go the default route (no instance passed) #
    else: path = Path(self.get_default_path())
    # Make the directory #
    path.make_directory()
    return path</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="plumbing" href="index.html">plumbing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="plumbing.cache.cached" href="#plumbing.cache.cached">cached</a></code></li>
<li><code><a title="plumbing.cache.expiry_every" href="#plumbing.cache.expiry_every">expiry_every</a></code></li>
<li><code><a title="plumbing.cache.property_pickled_at" href="#plumbing.cache.property_pickled_at">property_pickled_at</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="plumbing.cache.LazyDict" href="#plumbing.cache.LazyDict">LazyDict</a></code></h4>
<ul class="">
<li><code><a title="plumbing.cache.LazyDict.value" href="#plumbing.cache.LazyDict.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="plumbing.cache.LazyList" href="#plumbing.cache.LazyList">LazyList</a></code></h4>
<ul class="">
<li><code><a title="plumbing.cache.LazyList.value" href="#plumbing.cache.LazyList.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="plumbing.cache.LazyString" href="#plumbing.cache.LazyString">LazyString</a></code></h4>
<ul class="">
<li><code><a title="plumbing.cache.LazyString.value" href="#plumbing.cache.LazyString.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="plumbing.cache.class_property" href="#plumbing.cache.class_property">class_property</a></code></h4>
</li>
<li>
<h4><code><a title="plumbing.cache.invalidate_cache" href="#plumbing.cache.invalidate_cache">invalidate_cache</a></code></h4>
</li>
<li>
<h4><code><a title="plumbing.cache.property_cached" href="#plumbing.cache.property_cached">property_cached</a></code></h4>
<ul class="">
<li><code><a title="plumbing.cache.property_cached.check_cache" href="#plumbing.cache.property_cached.check_cache">check_cache</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="plumbing.cache.property_pickled" href="#plumbing.cache.property_pickled">property_pickled</a></code></h4>
<ul class="">
<li><code><a title="plumbing.cache.property_pickled.check_cache" href="#plumbing.cache.property_pickled.check_cache">check_cache</a></code></li>
<li><code><a title="plumbing.cache.property_pickled.get_default_path" href="#plumbing.cache.property_pickled.get_default_path">get_default_path</a></code></li>
<li><code><a title="plumbing.cache.property_pickled.get_pickle_path" href="#plumbing.cache.property_pickled.get_pickle_path">get_pickle_path</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>